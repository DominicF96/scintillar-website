import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { DocsMetadata, DocsCategory } from "@/types/docs.types";

// Valid categories that must have translations
const VALID_CATEGORIES: DocsCategory[] = [
  "basics",
  "configuration", 
  "features",
  "guides",
  "tutorials",
  "advanced",
  "integrations",
  "troubleshooting",
  "api",
  "general"
];

function getContentSubdirectories(dir: string): string[] {
  if (!fs.existsSync(dir)) {
    return [];
  }
  
  return fs.readdirSync(dir).filter((item) => {
    const itemPath = path.join(dir, item);
    return fs.statSync(itemPath).isDirectory();
  });
}

function getMetadataFromFile(filePath: string): DocsMetadata | null {
  try {
    const fileContent = fs.readFileSync(filePath, "utf8");
    const { data } = matter(fileContent);
    
    if (!data.id || !data.title || !data.date || !data.description) {
      console.warn(`Missing required metadata in ${filePath}`);
      return null;
    }
    
    // Validate category if provided
    if (data.category && !VALID_CATEGORIES.includes(data.category)) {
      console.warn(`Invalid category "${data.category}" in ${filePath}. Valid categories are: ${VALID_CATEGORIES.join(", ")}`);
      console.warn(`Falling back to "general" category. Please update the category or add translations for "${data.category}".`);
      data.category = "general";
    }
    
    return {
      id: data.id,
      title: data.title,
      author: data.author,
      date: data.date,
      description: data.description,
      category: data.category || "general",
    };
  } catch (error) {
    console.error(`Error reading file ${filePath}:`, error);
    return null;
  }
}

function generateDocsIndex(locale: string = "en"): DocsMetadata[] {
  const docsDir = path.join(process.cwd(), "src/content", locale, "docs");
  if (!fs.existsSync(docsDir)) {
    console.error(`Directory not found: ${docsDir}`);
    return [];
  }

  const subdirectories = getContentSubdirectories(docsDir);
  return subdirectories
    .map((subdir) => {
      const pagePath = path.join(docsDir, subdir, "page.mdx");
      console.log(`Processing docs page: ${pagePath}`);
      if (fs.existsSync(pagePath)) {
        const metadata = getMetadataFromFile(pagePath);
        if (metadata) {
          return {
            id: metadata.id,
            title: metadata.title,
            author: metadata.author,
            date: metadata.date,
            description: metadata.description,
            category: metadata.category,
          };
        }
      }
      return null;
    })
    .filter((docs): docs is NonNullable<typeof docs> => docs !== null && docs.id !== undefined)
    .sort((a, b) => {
      // Sort by category first, then by title
      if (a.category && b.category && a.category !== b.category) {
        return a.category.localeCompare(b.category);
      }
      return a.title.localeCompare(b.title);
    });
}

console.log("Starting docs index generation...");

// Generate index for both locales
const locales = ["en", "fr"];
locales.forEach(locale => {
  console.log(`Generating docs index for locale: ${locale}`);
  const docsIndex = generateDocsIndex(locale);
  const outputFilePath = path.join(process.cwd(), "src/content", locale, "docs/index.ts");

  const fileContent = `// This file is generated by docs-index.script.ts. Do not edit manually.
import { DocsMetadata } from "@/types/docs.types";

const data: DocsMetadata[] = ${JSON.stringify(docsIndex, null, 2)};

export default data;
`;

  // Ensure directory exists
  const outputDir = path.dirname(outputFilePath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(outputFilePath, fileContent, "utf8");
  console.log(`Docs index generated successfully at ${outputFilePath}`);
  console.log(`Generated ${docsIndex.length} documentation entries for ${locale}`);
});